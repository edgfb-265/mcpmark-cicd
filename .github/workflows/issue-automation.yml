name: Issue Management Automation

on:
  issues:
    types: [opened, labeled]

permissions:
  issues: write
  contents: read

jobs:
  issue-triage:
    runs-on: ubuntu-latest
    steps:
      - name: Triage Issue
        uses: actions/github-script@v7
        with:
          script: |
            const { title, body } = context.payload.issue;
            const issue_number = context.payload.issue.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Skip triage if it's a subtask created by the bot or script to avoid interference
            // Although requirements say "based on keywords", avoiding automated mess is good practice
            // But strict adherence to prompt: "Auto-assigns category labels based on keywords"
            // We will let it run but ensure no conflicts.
            
            const labelsToAdd = new Set();
            const lowerTitle = title.toLowerCase();
            
            if (lowerTitle.includes('bug')) labelsToAdd.add('bug');
            if (lowerTitle.includes('epic')) labelsToAdd.add('epic');
            if (lowerTitle.includes('maintenance')) labelsToAdd.add('maintenance');
            
            const combinedText = (title + ' ' + (body || '')).toLowerCase();
            let priorityLabel = 'priority-medium'; 
            
            if (['critical', 'urgent', 'production', 'outage'].some(k => combinedText.includes(k))) {
              priorityLabel = 'priority-critical';
            } else if (['important', 'high', 'blocking'].some(k => combinedText.includes(k))) {
              priorityLabel = 'priority-high';
            } else if (['medium', 'normal'].some(k => combinedText.includes(k))) {
              priorityLabel = 'priority-medium';
            } else if (['low', 'nice-to-have', 'minor'].some(k => combinedText.includes(k))) {
              priorityLabel = 'priority-low';
            }
            
            labelsToAdd.add(priorityLabel);
            
            // Check existing labels to avoid re-adding if not needed, 
            // but addLabels API is generally additive/idempotent-ish.
            // Requirement: "All issues get needs-triage label initially"
            labelsToAdd.add('needs-triage');

            if (labelsToAdd.size > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number,
                labels: Array.from(labelsToAdd)
              });
            }

  task-breakdown:
    needs: issue-triage
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, 'Epic') || contains(github.event.issue.title, 'epic')
    steps:
      - name: Create Sub-tasks
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Prevent recursion: do not break down subtasks even if they have "Epic" in title
            if (issue.title.includes('[SUBTASK]')) {
              console.log('This is a subtask, skipping breakdown.');
              return;
            }

            if (!issue.title.toLowerCase().includes('epic')) {
              return;
            }

            // Idempotency check
            if (issue.body && issue.body.includes('## Epic Tasks')) {
               console.log('Epic tasks section already exists.');
               return;
            }

            const subTasks = [
              "Requirements Analysis",
              "Design and Architecture",
              "Implementation",
              "Testing and Documentation"
            ];
            
            const createdSubIssues = [];
            
            for (let i = 0; i < subTasks.length; i++) {
              const taskName = subTasks[i];
              const subTitle = `[SUBTASK] ${issue.title} - Task ${i+1}: ${taskName}`;
              
              const subIssue = await github.rest.issues.create({
                owner,
                repo,
                title: subTitle,
                body: `Related to #${issue.number}`,
                labels: ['enhancement', 'needs-review']
              });
              
              createdSubIssues.push(subIssue.data);
            }
            
            let checklist = "\n\n## Epic Tasks\n";
            for (const sub of createdSubIssues) {
              checklist += `- [ ] #${sub.number}\n`;
            }
            
            const newBody = (issue.body || "") + checklist;
            
            await github.rest.issues.update({
              owner,
              repo,
              issue_number: issue.number,
              body: newBody
            });

  auto-response:
    needs: [issue-triage, task-breakdown]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Auto Response & Status Update
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // 1. First-time contributor check
            // We search for issues created by this user in this repo
            // If the count is 1 (this issue), it's their first.
            // Note: If the workflow runs on 'labeled', the issue is already created.
            // If the user has other issues, count > 1.
            
            const issuesByCreator = await github.rest.issues.listForRepo({
              owner,
              repo,
              creator: issue.user.login,
              state: 'all',
              per_page: 2 // We only need to know if > 1
            });
            
            const isFirstTime = issuesByCreator.data.length === 1;
            
            // Check if label already present to avoid double posting
            const { data: currentIssue } = await github.rest.issues.get({
               owner,
               repo,
               issue_number: issue.number
            });
            
            const currentLabels = currentIssue.labels.map(l => l.name);
            
            if (isFirstTime && !currentLabels.includes('first-time-contributor')) {
               await github.rest.issues.addLabels({
                 owner,
                 repo,
                 issue_number: issue.number,
                 labels: ['first-time-contributor']
               });
               
               await github.rest.issues.createComment({
                 owner,
                 repo,
                 issue_number: issue.number,
                 body: `Welcome @${issue.user.login}! Thanks for opening your first issue in this repository.`
               });
            }
            
            // 2. Post response based on type
            // Check if we already commented? 
            // The prompt says "Posts different responses". 
            // We should avoid spamming if the workflow runs multiple times (e.g. on label).
            // We can check comments, but maybe just checking if the specific label was just added?
            // Simpler: Just check if we haven't posted this specific message yet?
            // Or assume this runs on 'opened' mostly.
            // Let's check comments to be safe.
            
            const comments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: issue.number
            });
            
            const lowerTitle = issue.title.toLowerCase();
            let commentBody = "";
            let expectedSubstring = "";
            
            if (lowerTitle.includes('bug')) {
              commentBody = "Bug Report Guidelines: Please ensure you have provided reproduction steps.";
              expectedSubstring = "Bug Report Guidelines";
            } else if (lowerTitle.includes('epic')) {
              commentBody = "Feature Request Process: This epic has been broken down into sub-tasks.";
              expectedSubstring = "Feature Request Process";
            } else if (lowerTitle.includes('maintenance')) {
              commentBody = "Maintenance Guidelines: Thanks for helping keep the project clean.";
              expectedSubstring = "Maintenance Guidelines";
            }
            
            const alreadyCommented = comments.data.some(c => c.body.includes(expectedSubstring));
            
            if (commentBody && !alreadyCommented) {
               await github.rest.issues.createComment({
                 owner,
                 repo,
                 issue_number: issue.number,
                 body: commentBody
               });
            }
            
            // 3. Milestone for high/critical
            if (currentLabels.includes('priority-high') || currentLabels.includes('priority-critical')) {
               const milestones = await github.rest.issues.listMilestones({
                 owner,
                 repo,
                 state: 'open'
               });
               
               let milestone = milestones.data.find(m => m.title === 'v1.0.0');
               if (!milestone) {
                 milestone = (await github.rest.issues.createMilestone({
                   owner,
                   repo,
                   title: 'v1.0.0'
                 })).data;
               }
               
               // Only update if not set
               if (!currentIssue.milestone) {
                   await github.rest.issues.update({
                     owner,
                     repo,
                     issue_number: issue.number,
                     milestone: milestone.number
                   });
               }
            }
            
            // 4. Change status
            if (currentLabels.includes('needs-triage')) {
               await github.rest.issues.removeLabel({
                 owner,
                 repo,
                 issue_number: issue.number,
                 name: 'needs-triage'
               }).catch(err => console.log('Label needs-triage might not exist, ignoring'));
            }
            
            // Add needs-review if not present
             if (!currentLabels.includes('needs-review')) {
                await github.rest.issues.addLabels({
                   owner,
                   repo,
                   issue_number: issue.number,
                   labels: ['needs-review']
                });
             }
